#include "OTAUpdate.h"

#define LCD_COLS 20
#define LCD_ROWS 4
#define DEBUG 0

// ========================================
// CONFIGURATION - CHANGE THESE
// ========================================
const String baseURL = "https://dev-bj.github.io/CleanEnv-ESP32/";
const String versionURL = baseURL + "version.txt";
const String firmwareURL = baseURL + "firmware.bin";

const char* currentVersion = "1.0.0";  // UPDATE THIS AFTER EACH RELEASE
const int OTA_CHECK_INTERVAL = 300000;  // 5 minutes
const int MAX_RETRIES = 3;
bool isUpdating = false;

size_t otaSpace = 1000000; // Placeholder for available OTA space
WifiClientSecure wifiClient;

// ========================================
// HELPER FUNCTIONS
// ========================================
void updateLCDLine(LiquidCrystal& lcd, uint8_t row, const String &text, bool clear_line = true) {
    lcd.setCursor(0, row);
    lcd.print(text);
    if (clear_line) {
        // Print spaces to clear the rest of the line
        for (int i = text.length(); i < LCD_COLS; i++) {
            lcd.print(" ");
        }
    }
}

// ========================================
// VERSION COMPARISON FUNCTION
// ========================================
bool isNewerVersionAvailable(LiquidCrystal& lcd) {
  if (DEBUG) Serial.println("üìã Checking version...");
  lcd.clear();
  updateLCDLine(lcd, 1, "Checking for update");
  vTaskDelay(500 / portTICK_PERIOD_MS);

  // Only connect if not already connected.
  if (status.activeConnection != "WiFi" || WiFi.status() != WL_CONNECTED) {
    updateLCDLine(lcd, 2, "Waiting for WiFi...");
    int wait_attempts = 0;
    while(WiFi.status() != WL_CONNECTED && wait_attempts < 10) {
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        wait_attempts++;
    }
    if (WiFi.status() != WL_CONNECTED) return false; // Don't proceed if no WiFi
  }
  
  // Use static clients to avoid re-allocating memory on each check
  // static WiFiClientSecure client;
  // client.setCACert(github_ca);  // Use proper CA certificate
  
  static HTTPClient http;
  http.begin(client, versionURL);
  http.setTimeout(10000);
  
  int httpCode = http.GET();
  if (httpCode != HTTP_CODE_OK) {
    if (DEBUG) Serial.printf("‚ùå Version check failed: HTTP %d\n", httpCode);
    updateLCDLine(lcd, 2, "Check failed: " + String(httpCode));
    vTaskDelay(2000 / portTICK_PERIOD_MS);
    http.end();
    return false;
  }
  
  String serverVersion = http.getString();
  http.end();
  
  if (DEBUG) Serial.printf("üì± Current: %s | Server: %s\n", currentVersion, serverVersion.c_str());
  
  // Simple semantic version comparison (1.0.0 > 0.9.9)
  int currentNum = parseVersion(currentVersion);
  int serverNum = parseVersion(serverVersion.c_str());
  
  bool isNewer = (serverNum > currentNum);
  if (DEBUG) Serial.printf("‚û°Ô∏è %s update available!\n", isNewer ? "NEW" : "No");
  
  updateLCDLine(lcd, 2, isNewer ? "New version found!" : "Already up-to-date.");
  vTaskDelay(1000 / portTICK_PERIOD_MS);
  
  return isNewer;
}

// Helper: Convert "1.2.3" ‚Üí 10203 (major*10000 + minor*100 + patch)
int parseVersion(const char* ver) {
  int major = 0, minor = 0, patch = 0;
  sscanf(ver, "%d.%d.%d", &major, &minor, &patch);
  return major * 10000 + minor * 100 + patch;
}

// ========================================
// MAIN OTA FUNCTION
// ========================================
bool performSecureOTA(LiquidCrystal& lcd) {
  if (DEBUG) Serial.println("\nüîÑ === STARTING OTA UPDATE ===");
  client.setCACert(github_ca);  // Use proper CA certificate
  
  // 1. VERSION CHECK
  if (!isNewerVersionAvailable(lcd)) {
    if (DEBUG) Serial.println("‚úÖ Already up-to-date or check failed!");
    delay(1000); // Show message on LCD
    lcd.clear();
    return false;
  }
  
  // 2. CHECK OTA SPACE
  // if (!Update.canBegin()) {
  //   if (DEBUG) Serial.println("‚ùå ERROR: No space for OTA update!");
  //   updateLCDLine(lcd, 3, "Not enough space!");
  //   delay(2000);
  //   return false;
  // }

  delay(2000); // Give user time to see "New version found"
  updateLCDLine(lcd, 0, "Starting OTA Update");

  if (status.activeConnection != "WiFi" || WiFi.status() != WL_CONNECTED) {
    updateLCDLine(lcd, 1, "Waiting for WiFi...");
    int wait_attempts = 0;
    while(WiFi.status() != WL_CONNECTED && wait_attempts < 10) {
        vTaskDelay(1000 / portTICK_PERIOD_MS);
        wait_attempts++;
    }
    if (WiFi.status() != WL_CONNECTED) return false; // Don't proceed if no WiFi
  }
  
  // 3. HTTPS CLIENT
  // Use static clients to avoid re-allocating memory on each check
  // static WiFiClientSecure client;
  // client.setCACert(github_ca);  // Use proper CA certificate
  
  static HTTPClient http;
  http.begin(client, firmwareURL);
  http.setTimeout(30000);
  
  // 4. RETRY LOOP
  for (int retry = 0; retry < MAX_RETRIES; retry++) {
    if (DEBUG) Serial.printf("üì° Download attempt %d/%d...\n", retry + 1, MAX_RETRIES);
    updateLCDLine(lcd, 1, "Downloading attempt " + String(retry + 1));
    
    int httpCode = http.GET();
    
    if (httpCode == HTTP_CODE_OK) {
      int contentLength = http.getSize();
      if (DEBUG) Serial.printf("üì¶ Firmware: %d bytes\n", contentLength);
      
      if (contentLength <= 0) {
        if (DEBUG) Serial.println("‚ùå Empty firmware file!");
        updateLCDLine(lcd, 2, "Error: Firmware empty!");
        http.end();
        return false;
      }
      
      // 5. START UPDATE
      if (!Update.begin(contentLength)) {
        if (DEBUG) Serial.printf("‚ùå Update begin failed! Error: %u\n", Update.getError());
        Update.printError(Serial);
        updateLCDLine(lcd, 2, "Update Error: " + String(Update.getError()));
        http.end();
        return false;
      }
      
      // 6. DOWNLOAD WITH PROGRESS
      WiFiClient* stream = http.getStreamPtr();
      uint8_t buff[1024] = {0};
      size_t totalRead = 0;
      size_t lastProgress = 0;
      isUpdating = true;
      
      while (http.connected()) {
        size_t bytesRead = stream->readBytes(buff, sizeof(buff));
        if (bytesRead == 0) break;
        
        Update.write(buff, bytesRead);
        totalRead += bytesRead;
        
        // Progress every 1% for better feedback
        size_t progress = (totalRead * 100) / contentLength;
        if (progress > lastProgress) {
          if (DEBUG) Serial.printf("\rüì• %u%% (%u/%u)", progress, totalRead, contentLength);
          updateLCDLine(lcd, 2, "Progress: " + String(progress) + "%", false);
          lastProgress = progress;
        }
      }
      if (DEBUG) Serial.println("\rüì• 100% Complete!          ");
      updateLCDLine(lcd, 2, "Progress: 100%", true);
      
      // 7. FINALIZE
      if (Update.end(true)) {  // true = verify
        if (DEBUG) Serial.printf("‚úÖ OTA SUCCESS! Updated to v%s\n", currentVersion);
        lcd.clear();
        updateLCDLine(lcd, 1, "Update Successful!");
        updateLCDLine(lcd, 2, "Rebooting...");
        if (DEBUG) Serial.println("üîÑ Rebooting in 3...");
        http.end();
        delay(3000);
        ESP.restart();
        return true;
      } else {
        if (DEBUG) Serial.printf("‚ùå Update FAILED! Error: %u\n", Update.getError());
        Update.printError(Serial);
        lcd.clear();
        updateLCDLine(lcd, 1, "Update Failed!");
        updateLCDLine(lcd, 2, "Error: " + String(Update.getError()));
      }
    } else {
      if (DEBUG) Serial.printf("‚ùå HTTP %d\n", httpCode);
      updateLCDLine(lcd, 2, "Download failed: " + String(httpCode));
    }
    
    http.end();
    if (retry < MAX_RETRIES - 1) {
      if (DEBUG) Serial.println("‚è≥ Waiting 2s before retry...");
      updateLCDLine(lcd, 3, "Retrying in 2s...");
      delay(2000);
    }
  }
  
  if (DEBUG) Serial.println("‚ùå OTA FAILED - Check server!");
  lcd.clear();
  updateLCDLine(lcd, 1, "OTA Failed.");
  updateLCDLine(lcd, 2, "Check server/URL.");
  delay(3000);
  lcd.clear();
  return false;
}